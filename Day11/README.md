## Singleton 패턴

singleton 패턴은 **인스턴스가 오직 1개만 생성** 되어야 하는 경우에 사용되는 패턴이다.

예를 들어 레지스트리같은 설정 파일의 경우 객체가 여러개 생성되면 설정 값이 변경될 위험이 생길 수 있다.   

```sql
public class ExampleClass {
    //Instance
    private static ExampleClass instance = new ExampleClass();

    //private construct
    private ExampleClass() {}

    public static ExampleClass getInstance() {
        return instance;
    }
}
```

위 코드에서는 instance라는 전역 변수를 선언하는데 **static**을 줌으로써 인스턴스화 하지 않고 사용할 수 있게 하였지만 접근 제한자가 **private** 로 되어 있어 직접적인 접근은 불가능하다.

또한 생성자도 private으로 되어 있어 **new** 를 통한 객체 생성도 불가능하며, 결국 getInstance 메서드를 통해서 해당 인스턴스를 얻을 수 있게 된다.

따라서 인스턴스가 1개만 생성되는 특징을 가진 singleton 패턴을 이용하면, 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용하게끔 할 수 있으므로, 요청이 많은 곳에서 사용하면 효율을 높일 수 있다.

하지만 문제점도 존재한다. 다른 객체와 공통으로 사용하는 경우와 같은 몇 가지 케이스에서만 사용할 때 효율적이며 그 외에는 문제점이 생길 수 있다.  

일단 싱글톤으로 만든 객체의 역할이 간단한 것이 아닌 역할이 복잡한 경우라면 해당 싱글톤 객체를 사용하는 **다른 객체간의 결함도**가 높아져서 객체 지향 설계 원칙에 어긋나게 된다.

## Factory Method 패턴

팩토리 패턴은 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브 클래스 쪽에서 내리는 패턴이다. 

다시 말해 **여러 개의 서브 클래스를 가진 슈퍼 클래스가 있을 때 인풋에 따라 하나의 자식 클래스의 인스턴스를 리턴해주는 방식**이다.

팩토리 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브 클래스로 미룬다.

이 패턴은 인스턴스화에 대한 책임을 객체를 사용하는 클라이언트에서 팩토리 클래스로 가져온다. 

팩토리 패턴은 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때, 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때 활용한다.

팩토리 패턴의 장점으로는 클라이언트 코드로부터 서브 클래스의 인스턴스화를 제거하여 서로 간의 종속성을 낮추고, 결합도를 느슨하게 하며, 확장을 쉽게 한다.

예를 들어, 작성한 서브클래스에 대해 수정 혹은 삭제가 일어나더라도 클라이언트는 알 수 없기 때문에 코드를 변경할 필요가 없다.

또한 팩토리패턴은 클라이언트와 구현 객체들 사이에 추상화를 제공한다.